from flask import Blueprint, render_template, redirect, url_for, flash, request, abort
from .. import db
from ..models import User, Transaction, Category, Account
from .forms import SignupForm, LoginForm, TransactionForm
from flask_login import login_user, logout_user, login_required, current_user
from datetime import date
from sqlalchemy.orm import joinedload
from flask_wtf.csrf import generate_csrf

main_bp = Blueprint("main", __name__, template_folder="templates")

def recompute_account_balance(account):
    """Recompute the account.balance from all transactions for that account."""
    txns = Transaction.query.filter_by(account_id=account.id).all()
    balance = 0.0
    for t in txns:
        amt = float(t.amount or 0.0)
        balance += amt if getattr(t, "type", "") == "income" else -amt
    account.balance = balance
    db.session.commit()

@main_bp.route('/')
def index():
    return render_template('main/index.html')

@main_bp.route("/edit_transaction/<int:tx_id>", methods=["GET", "POST"])
@login_required
def edit_transaction(tx_id):
    # ensure this transaction belongs to the current user by joining Account
    txn = (
        Transaction.query
        .join(Account, Transaction.account_id == Account.id)
        .filter(Transaction.id == tx_id, Account.user_id == current_user.id)
        .first_or_404()
    )

    form = TransactionForm(obj=txn)

    # Pre-fill category name on GET since TransactionForm uses a StringField for category
    if request.method == 'GET' and txn.category:
        form.category.data = txn.category.name

    if form.validate_on_submit():
        # Update transaction fields
        txn.description = form.description.data
        txn.amount = float(form.amount.data)
        txn.type = form.type.data
        txn.transaction_date = form.date.data

        # find or create category for this user
        cat = Category.query.filter_by(user_id=current_user.id, name=form.category.data).first()
        if not cat:
            cat = Category(user_id=current_user.id, name=form.category.data, type=form.type.data)
            db.session.add(cat)
            db.session.commit()
        txn.category_id = cat.id

        db.session.commit()

        # recompute account balance to be safe
        if txn.account:
            recompute_account_balance(txn.account)

        flash("Transaction updated successfully!", "success")
        return redirect(url_for("main.dashboard"))

    # If POST and validation failed, flash errors
    if request.method == "POST":
        for field, errs in form.errors.items():
            for e in errs:
                flash(f"{field}: {e}", "danger")

    return render_template("main/edit_transaction.html", form=form, txn=txn)


@main_bp.route("/delete_transaction/<int:tx_id>", methods=["POST"])
@login_required
def delete_transaction(tx_id):
    txn = (
        Transaction.query
        .join(Account, Transaction.account_id == Account.id)
        .filter(Transaction.id == tx_id, Account.user_id == current_user.id)
        .first_or_404()
    )

    account = txn.account
    db.session.delete(txn)
    db.session.commit()

    # recompute account balance after deletion
    if account:
        recompute_account_balance(account)

    flash("Transaction deleted.", "info")
    return redirect(url_for("main.dashboard"))


@main_bp.route('/dashboard')
@login_required
def dashboard():
    # Get user's accounts and categories
    accounts = Account.query.filter_by(user_id=current_user.id).all()
    categories = Category.query.filter_by(user_id=current_user.id).all()

    # Base query: include joinedload so t.account and t.category are available without extra queries
    q = (
        Transaction.query
        .options(
            joinedload(Transaction.account),
            joinedload(Transaction.category)
        )
        .join(Account, Transaction.account_id == Account.id)
        .filter(Account.user_id == current_user.id)
    )

    # Optional filters (from querystring) for future use / UI
    start = request.args.get("start_date")
    end = request.args.get("end_date")
    cat = request.args.get("category")  # expects category name; you can switch to id if preferred
    qtext = request.args.get("q")

    if start:
        q = q.filter(Transaction.transaction_date >= start)
    if end:
        q = q.filter(Transaction.transaction_date <= end)
    if cat:
        # join category and filter by name
        q = q.join(Category, Transaction.category_id == Category.id).filter(Category.name == cat)
    if qtext:
        q = q.filter(Transaction.description.ilike(f"%{qtext}%"))

    transactions = q.order_by(Transaction.transaction_date.desc()).all()

    # Summaries (same logic you used)
    total_income = sum(float(t.amount or 0.0) for t in transactions if getattr(t, "type", "") == "income")
    total_expense = sum(float(t.amount or 0.0) for t in transactions if getattr(t, "type", "") != "income")
    total_balance = sum(float(a.balance or 0.0) for a in accounts) if accounts else (total_income - total_expense)

    # If you already have CSRFProtect(app) enabled globally, you don't need to pass generate_csrf.
    # But if not, passing this lets your template call csrf_token() to get a token for the inline delete form.
    return render_template(
        'main/dashboard.html',
        accounts=accounts,
        categories=categories,
        transactions=transactions,
        total_income=total_income,
        total_expense=total_expense,
        total_balance=total_balance,
        csrf_token=generate_csrf  # optional: template can call csrf_token()
    )


@main_bp.route("/login", methods=["GET", "POST"])
def login():
    if current_user.is_authenticated:
        return redirect(url_for("main.dashboard"))

    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        if user and user.check_password(form.password.data):
            login_user(user)
            flash("Logged in successfully!", "success")
            next_page = request.args.get("next")
            return redirect(next_page or url_for("main.dashboard"))
        else:
            flash("Invalid email or password", "danger")
    return render_template("main/login.html", form=form)

@main_bp.route("/signup", methods=["GET", "POST"])
def signup():
    form = SignupForm()
    if form.validate_on_submit():
        # Check if email already exists
        if User.query.filter_by(email=form.email.data).first():
            flash("Email already registered. Please log in.", "warning")
            return redirect(url_for("main.signup"))

        # Create new user
        new_user = User(
            email=form.email.data,
            username=form.username.data or None,
        )
        new_user.set_password(form.password.data)

        db.session.add(new_user)
        db.session.commit()

        flash("Signup successful! You can now log in.", "success")
        return redirect(url_for("main.login"))

    return render_template("main/signup.html", form=form)

@main_bp.route("/add_transaction", methods=["GET", "POST"])
@login_required
def add_transaction():
    form = TransactionForm()

    # Optionally populate category choices if you convert Category field to SelectField later
    if form.validate_on_submit():
        # Ensure user has at least one account
        account = Account.query.filter_by(user_id=current_user.id).first()
        if not account:
            account = Account(
                user_id=current_user.id,
                name="Default Wallet",
                type="Wallet",
                balance=0.0
            )
            db.session.add(account)
            db.session.commit()  # commit to get account.id

        # Find or create category for current user
        cat = Category.query.filter_by(user_id=current_user.id, name=form.category.data).first()
        if not cat:
            cat = Category(
                user_id=current_user.id,
                name=form.category.data,
                type=form.type.data  # set type from form (income/expense)
            )
            db.session.add(cat)
            db.session.commit()  # commit to get cat.id

        # Create Transaction â€” use the model's field names (account_id, category_id, transaction_date)
        new_txn = Transaction(
            account_id=account.id,
            category_id=cat.id,
            amount=float(form.amount.data),
            type=form.type.data,
            description=form.description.data,
            transaction_date=form.date.data  # use the field name in your model
        )
        db.session.add(new_txn)

        # Update account balance (simple logic)
        if form.type.data == "income":
            account.balance = (account.balance or 0.0) + float(form.amount.data)
        else:
            account.balance = (account.balance or 0.0) - float(form.amount.data)

        db.session.commit()
        flash("Transaction added successfully!", "success")
        return redirect(url_for("main.dashboard"))

    # If POST and validation failed, flash errors so you can see them in UI
    if request.method == "POST":
        for field, errs in form.errors.items():
            for e in errs:
                flash(f"{field}: {e}", "danger")

    return render_template("main/add_transaction.html", form=form)

@main_bp.route("/logout")
@login_required
def logout():
    logout_user()
    flash("You have been logged out.", "info")
    return redirect(url_for("main.login"))
